## 문제
----------
[백준 17298 오큰수: https://www.acmicpc.net/problem/17298](https://www.acmicpc.net/problem/17298)

## 문제 설명
---------------
N의 크기를 가지는 수열 A에 대해서 i번째의 수열의 오른쪽 수 중 가장 가까운 큰 수를 구하는 문제다. 예를 들어, 3 5 2 7이라는 수열 A에 대해서 3의 오큰수는 오른쪽 수 5, 2, 7 중 가장 가까운(즉, 가장 왼쪽에 있는) 큰 수인 5이다. 구할려는 오큰 수가 없을 시 -1을 반환한다. 또한, 이 문제의 시간 복잡도는 O((nlogn)이하여야 한다.

## 풀이
---------------
스택에 수를 넣는 대신 인덱스를 넣어서 바로 오른쪽에 오큰 수가 있는지 판단하는 방법으로 진행한다. 바로 오른쪽에 있는 오큰수가 스택에 쌓여있는 모든 수의 오큰 수가 된다. 예를 들어, 9 5 4 8이라는 수열로 오큰 수를 구할 시 인덱스 2까지 push한 다음 바로 오른쪽에 있는 수 8과 비교시 8이 더 크고 가장 가까운 수이므로 오큰수이다. 스택에 인덱스가 남아있을 시 인덱스에 해당하는 수들의 오큰 수도 8이 된다. !s.empty() && arr[s.top()] << arr[i]가 소스 코드의 핵심 조건이다.

## 소스 코드
-------------
```C++
#include <iostream>
#include <vector>
#include <stack>

using namespace std;

int main()
{
    stack<int> s;
    int N;

    scanf("%d", &N);

    int *arr = new int[N];
    vector<int> v(N, -1);

    for (int i = 0; i < N; i++)
        scanf("%d", &arr[i]);

    for (int i = 0; i < N; i++)
    {
        while (!s.empty() && arr[s.top()] < arr[i])
        {
            v[s.top()] = arr[i];
            s.pop();
        }

        s.push(i);
    }
            
    for (int i = 0; i < N; i++)
        printf("%d ", v[i]);

    delete[] arr;

    return 0;
}
```

## 주의 사항
----------------
수 하나에 대해 오른쪽에 있는 모든 수를 탐색하는 방법은 O(n^2)의 시간을 소비하므로 좋은 방법이 아니다. 위의 소스코드는 O(n)의 시간을 소비한다.

## 리뷰
-----------
자료구조를 막 입문하는 사람에게는 어려운 문제이다. 결국 구글링을 통해서 답을 알아냈다. 뒷 인덱스부터 구하고 앞 인덱스를 구하는 식의 문제들은 스택에 인덱스를 넣어 풀면 더 빠르다는 것을 알게 되었다. 코드를 보고 시간 복잡도도 생각해야하는 능력도 길러야 한다는 것을 깨닫게 해주는 문제이다.